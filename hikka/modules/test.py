# ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ    ‚ñÑ‚ñÄ‚ñà ‚ñÄ‚ñà‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ‚ñÄ‚ñà ‚ñÑ‚ñÄ‚ñà
# ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà ‚ñÑ  ‚ñà‚ñÄ‚ñà  ‚ñà  ‚ñà‚ñÄ‚ñà ‚ñà ‚ñÄ ‚ñà ‚ñà‚ñÄ‚ñà
#
#              ¬© Copyright 2022
#
#          https://t.me/hikariatama
#
# üîí Licensed under the GNU GPLv3
# üåê https://www.gnu.org/licenses/agpl-3.0.html

# scope: inline

import asyncio
import inspect
import logging
import os
import time
from io import BytesIO
from typing import Union

from telethon.tl.types import Message

from .. import loader, main, utils
from ..inline.types import InlineCall

logger = logging.getLogger(__name__)
DEBUG_MODS_DIR = os.path.join(utils.get_base_dir(), "debug_modules")

if not os.path.isdir(DEBUG_MODS_DIR):
    os.mkdir(DEBUG_MODS_DIR, mode=0o755)

for mod in os.scandir(DEBUG_MODS_DIR):
    os.remove(mod.path)


@loader.tds
class TestMod(loader.Module):
    """Perform operations based on userbot self-testing"""

    _memory = {}

    strings = {
        "name": "Tester",
        "set_loglevel": "üö´ <b>Please specify verbosity as an integer or string</b>",
        "no_logs": "‚ÑπÔ∏è <b>You don't have any logs at verbosity {}.</b>",
        "logs_filename": "hikka-logs.txt",
        "logs_caption": "üåò <b>Hikka logs with verbosity </b><code>{}</code>\n\nüë©‚Äçüé§ <b>Hikka version: {}.{}.{}</b>{}\n‚è± <b>Uptime: {}</b>\n<b>{}</b>\n\n<b>{}</b>\n\n<b>{} NoNick</b>\n<b>{} Grep</b>\n<b>{} InlineLogs</b>",
        "suspend_invalid_time": "üö´ <b>Invalid time to suspend</b>",
        "suspended": "ü•∂ <b>Bot suspended for</b> <code>{}</code> <b>seconds</b>",
        "results_ping": "‚è± <b>Response time:</b> <code>{}</code> <b>ms</b>\nüë©‚Äçüíº <b>Uptime: {}</b>",
        "confidential": "‚ö†Ô∏è <b>Log level </b><code>{}</code><b> may reveal your confidential info, be careful</b>",
        "confidential_text": (
            "‚ö†Ô∏è <b>Log level </b><code>{0}</code><b> may reveal your confidential info, "
            "be careful</b>\n<b>Type </b><code>.logs {0} force_insecure</code><b> "
            "to ignore this warning</b>"
        ),
        "choose_loglevel": "üíÅ‚Äç‚ôÇÔ∏è <b>Choose log level</b>",
        "database_unlocked": "üö´ DB eval unlocked",
        "database_locked": "‚úÖ DB eval locked",
        "bad_module": "üö´ <b>Module not found</b>",
        "debugging_enabled": "üßë‚Äçüíª <b>Debugging mode enabled for module </b><code>{0}</code>\n<i>Go to directory named `debug_modules`, edit file named `{0}.py` and see changes in real time</i>",
        "debugging_disabled": "‚úÖ <b>Debugging disabled</b>",
    }

    strings_ru = {
        "set_loglevel": "üö´ <b>–£–∫–∞–∂–∏ —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–æ–≤ —á–∏—Å–ª–æ–º –∏–ª–∏ —Å—Ç—Ä–æ–∫–æ–π</b>",
        "no_logs": "‚ÑπÔ∏è <b>–£ —Ç–µ–±—è –Ω–µ—Ç –ª–æ–≥–æ–≤ —É—Ä–æ–≤–Ω—è {}.</b>",
        "logs_filename": "hikka-logs.txt",
        "logs_caption": "üåò <b>–õ–æ–≥–∏ Hikka —É—Ä–æ–≤–Ω—è </b><code>{}</code>\n\nüë©‚Äçüé§ <b>–í–µ—Ä—Å–∏—è Hikka: {}.{}.{}</b>{}\n‚è± <b>Uptime: {}</b>\n<b>{}</b>\n\n<b>{}</b>\n\n<b>{} NoNick</b>\n<b>{} Grep</b>\n<b>{} InlineLogs</b>",
        "database_unlocked": "üö´ –ë–∞–∑–∞ —Å–∫–æ–º–ø—Ä–æ–º–µ—Ç–∏—Ä–æ–≤–∞–Ω–∞",
        "database_locked": "‚úÖ –ë–∞–∑–∞ –∑–∞—â–∏—â–µ–Ω–∞",
        "bad_module": "üö´ <b>–ú–æ–¥—É–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω</b>",
        "debugging_enabled": "üßë‚Äçüíª <b>–†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –≤–∫–ª—é—á–µ–Ω –¥–ª—è –º–æ–¥—É–ª—è </b><code>{0}</code>\n<i>–û—Ç–ø—Ä–∞–≤–ª—è–π—Å—è –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é `debug_modules`, –∏–∑–º–µ–Ω—è–π —Ñ–∞–π–ª `{0}.py`, –∏ —Å–º–æ—Ç—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏</i>",
        "debugging_disabled": "‚úÖ <b>–†–µ–∂–∏–º —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –≤—ã–∫–ª—é—á–µ–Ω</b>",
        "suspend_invalid_time": "üö´ <b>–ù–µ–≤–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–º–æ—Ä–æ–∑–∫–∏</b>",
        "suspended": "ü•∂ <b>–ë–æ—Ç –∑–∞–º–æ—Ä–æ–∂–µ–Ω –Ω–∞</b> <code>{}</code> <b>—Å–µ–∫—É–Ω–¥</b>",
        "results_ping": "‚è± <b>–°–∫–æ—Ä–æ—Å—Ç—å –æ—Ç–∫–ª–∏–∫–∞:</b> <code>{}</code> <b>ms</b>\nüë©‚Äçüíº <b>–ü—Ä–æ—à–ª–æ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏: {}</b>",
        "confidential": "‚ö†Ô∏è <b>–£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–æ–≤ </b><code>{}</code><b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ª–∏—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é, –±—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω</b>",
        "confidential_text": "‚ö†Ô∏è <b>–£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–æ–≤ </b><code>{0}</code><b> –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ª–∏—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é, –±—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω</b>\n<b>–ù–∞–ø–∏—à–∏ </b><code>.logs {0} force_insecure</code><b>, —á—Ç–æ–±—ã –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ª–æ–≥–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—è –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ</b>",
        "choose_loglevel": "üíÅ‚Äç‚ôÇÔ∏è <b>–í—ã–±–µ—Ä–∏ —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–æ–≤</b>",
        "_cmd_doc_dump": "–ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–æ–æ–±—â–µ–Ω–∏–∏",
        "_cmd_doc_logs": "<—É—Ä–æ–≤–µ–Ω—å> - –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ª–æ–≥-—Ñ–∞–π–ª. –£—Ä–æ–≤–Ω–∏ –Ω–∏–∂–µ WARNING –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ª–∏—á–Ω—É—é –∏–Ω—Ñ–æ–º—Ä–∞—Ü–∏—é.",
        "_cmd_doc_suspend": "<–≤—Ä–µ–º—è> - –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å –±–æ—Ç–∞ –Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è",
        "_cmd_doc_ping": "–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–∫–æ—Ä–æ—Å—Ç—å –æ—Ç–∫–ª–∏–∫–∞ —é–∑–µ—Ä–±–æ—Ç–∞",
        "_cls_doc": "–û–ø–µ—Ä–∞—Ü–∏–∏, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —Å–∞–º–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º",
    }

    @staticmethod
    async def dumpcmd(message: Message):
        """Use in reply to get a dump of a message"""
        if not message.is_reply:
            return

        await utils.answer(
            message,
            "<code>"
            + utils.escape_html((await message.get_reply_message()).stringify())
            + "</code>",
        )

    @staticmethod
    async def cancel(call: InlineCall):
        await call.delete()

    async def watchdog(self):
        while True:
            try:
                for module in os.scandir(DEBUG_MODS_DIR):
                    last_modified = os.stat(module.path).st_mtime
                    cls_ = module.path.split("/")[-1].split(".py")[0]

                    if cls_ not in self._memory:
                        self._memory[cls_] = last_modified
                        continue

                    if self._memory[cls_] == last_modified:
                        continue

                    self._memory[cls_] = last_modified
                    logger.debug(f"Reloading debug module {cls_}")
                    with open(module.path, "r") as f:
                        try:
                            await next(
                                module
                                for module in self.allmodules.modules
                                if module.__class__.__name__ == "LoaderMod"
                            ).load_module(
                                f.read(),
                                None,
                                save_fs=False,
                            )
                        except Exception:
                            logger.exception("Failed to reload module in watchdog")
            except Exception:
                logger.exception("Failed debugging watchdog")
                return

            await asyncio.sleep(1)

    async def debugmodcmd(self, message: Message):
        """[module] - For developers: Open module for debugging
        You will be able to track changes in real-time"""
        args = utils.get_args_raw(message)
        instance = None
        for module in self.allmodules.modules:
            if (
                module.__class__.__name__.lower() == args.lower()
                or module.strings["name"].lower() == args.lower()
            ):
                if os.path.isfile(
                    os.path.join(
                        DEBUG_MODS_DIR,
                        f"{module.__class__.__name__}.py",
                    )
                ):
                    os.remove(
                        os.path.join(
                            DEBUG_MODS_DIR,
                            f"{module.__class__.__name__}.py",
                        )
                    )

                    try:
                        delattr(module, "hikka_debug")
                    except AttributeError:
                        pass

                    await utils.answer(message, self.strings("debugging_disabled"))
                    return

                module.hikka_debug = True
                instance = module
                break

        if not instance:
            await utils.answer(message, self.strings("bad_module"))
            return

        with open(
            os.path.join(
                DEBUG_MODS_DIR,
                f"{instance.__class__.__name__}.py",
            ),
            "wb",
        ) as f:
            f.write(inspect.getmodule(instance).__loader__.data)

        await utils.answer(
            message,
            self.strings("debugging_enabled").format(instance.__class__.__name__),
        )

    async def logscmd(
        self,
        message: Union[Message, InlineCall],
        force: bool = False,
        lvl: Union[int, None] = None,
    ):
        """<level> - Dumps logs. Loglevels below WARNING may contain personal info."""
        if not isinstance(lvl, int):
            args = utils.get_args_raw(message)
            try:
                try:
                    lvl = int(args.split()[0])
                except ValueError:
                    lvl = getattr(logging, args.split()[0].upper(), None)
            except IndexError:
                lvl = None

        if not isinstance(lvl, int):
            try:
                if not self.inline.init_complete or not await self.inline.form(
                    text=self.strings("choose_loglevel"),
                    reply_markup=[
                        [
                            {
                                "text": "üö® Critical",
                                "callback": self.logscmd,
                                "args": (False, 50),
                            },
                            {
                                "text": "üö´ Error",
                                "callback": self.logscmd,
                                "args": (False, 40),
                            },
                        ],
                        [
                            {
                                "text": "‚ö†Ô∏è Warning",
                                "callback": self.logscmd,
                                "args": (False, 30),
                            },
                            {
                                "text": "‚ÑπÔ∏è Info",
                                "callback": self.logscmd,
                                "args": (False, 20),
                            },
                        ],
                        [
                            {
                                "text": "üßë‚Äçüíª Debug",
                                "callback": self.logscmd,
                                "args": (False, 10),
                            },
                            {
                                "text": "üëÅ All",
                                "callback": self.logscmd,
                                "args": (False, 0),
                            },
                        ],
                        [{"text": "üö´ Cancel", "callback": self.cancel}],
                    ],
                    message=message,
                ):
                    raise
            except Exception:
                await utils.answer(message, self.strings("set_loglevel"))

            return

        logs = "\n\n".join(
            [
                ("\n".join(handler.dumps(lvl)))
                for handler in logging.getLogger().handlers
            ]
        )

        named_lvl = (
            lvl
            if lvl not in logging._levelToName
            else logging._levelToName[lvl]  # skipcq: PYL-W0212
        )

        if (
            lvl < logging.WARNING
            and not force
            and (
                not isinstance(message, Message)
                or "force_insecure" not in message.raw_text.lower()
            )
        ):
            try:
                if not self.inline.init_complete:
                    raise

                cfg = {
                    "text": self.strings("confidential").format(named_lvl),
                    "reply_markup": [
                        {
                            "text": "üì§ Send anyway",
                            "callback": self.logscmd,
                            "args": [True, lvl],
                        },
                        {"text": "üö´ Cancel", "callback": self.cancel},
                    ],
                }
                if isinstance(message, Message):
                    if not await self.inline.form(**cfg, message=message):
                        raise
                else:
                    await message.edit(**cfg)
            except Exception:
                await utils.answer(
                    message,
                    self.strings("confidential_text").format(named_lvl),
                )

            return

        if len(logs) <= 2:
            if isinstance(message, Message):
                await utils.answer(message, self.strings("no_logs").format(named_lvl))
            else:
                await message.edit(self.strings("no_logs").format(named_lvl))
                await message.unload()

            return

        if btoken := self._db.get("hikka.inline", "bot_token", False):
            logs = logs.replace(
                btoken,
                f'{btoken.split(":")[0]}:***************************',
            )

        if hikka_token := self._db.get("HikkaDL", "token", False):
            logs = logs.replace(
                hikka_token,
                f'{hikka_token.split("_")[0]}_********************************',
            )

        if hikka_token := self._db.get("Kirito", "token", False):
            logs = logs.replace(
                hikka_token,
                f'{hikka_token.split("_")[0]}_********************************',
            )

        logs = BytesIO(logs.encode("utf-16"))
        logs.name = self.strings("logs_filename")

        ghash = utils.get_git_hash()

        other = (
            *main.__version__,
            f' <i><a href="https://github.com/hikariatama/Hikka/commit/{ghash}">({ghash[:8]})</a></i>'
            if ghash
            else "",
            utils.formatted_uptime(),
            utils.get_named_platform(),
            self.strings(
                f"database_{'un' if self._db.get(main.__name__, 'enable_db_eval', False) else ''}locked"
            ),
            "‚úÖ" if self._db.get(main.__name__, "no_nickname", False) else "üö´",
            "‚úÖ" if self._db.get(main.__name__, "grep", False) else "üö´",
            "‚úÖ" if self._db.get(main.__name__, "inlinelogs", False) else "üö´",
        )


        if getattr(message, "out", True):
            await message.delete()

        if isinstance(message, Message):
            await utils.answer(
                message,
                logs,
                caption=self.strings("logs_caption").format(named_lvl, *other),
            )
        else:
            await self._client.send_file(
                message.form["chat"],
                logs,
                caption=self.strings("logs_caption").format(named_lvl, *other),
            )

    @loader.owner
    async def suspendcmd(self, message: Message):
        """<time> - Suspends the bot for N seconds"""
        try:
            time_sleep = float(utils.get_args_raw(message))
            await utils.answer(
                message,
                self.strings("suspended").format(time_sleep),
            )
            time.sleep(time_sleep)
        except ValueError:
            await utils.answer(message, self.strings("suspend_invalid_time"))

    async def pingcmd(self, message: Message):
        """Test your userbot ping"""
        start = time.perf_counter_ns()
        message = await utils.answer(message, "<code>üêª Nofin...</code>")
        await utils.answer(
            message,
            self.strings("results_ping").format(
                round((time.perf_counter_ns() - start) / 10**6, 3),
                utils.formatted_uptime(),
            ),
        )

    async def client_ready(self, client, db):
        self._client = client
        self._db = db
        self._task = asyncio.ensure_future(self.watchdog())
